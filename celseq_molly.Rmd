---
title: "Gene expression analysis of swsn-1 KO M lineage of *c. elegans*"
author: "Xiang Zhang"
date: "`r format(Sys.Date(), '%d %B, %Y')`"
output: 
  html_document: 
    toc: true
    toc_float: 
      collapsed: true
editor_options: 
  chunk_output_type: console
bibliography: /home/xiang/Documents/Bibliography/c_elegans.bib
---

```{r include=FALSE,message=FALSE}
library(purrr)
library(tibble)
library(dplyr)
library(ggplot2)
library(forcats)
library(stringr)
library(tidyr)
library(GGally)
library(edgeR)
source("./scripts/R/customized_functions.R")
```

# Introduction

I work with the data files provided by Singe Cell Discoveries. 
This is a bulk RNAseq data set generated by the CEL-seq protocol. 
There are two groups swsn-1 "KO" (labeled as "lox") and wild type (labeled as "wt"). 

```{r include=FALSE}
dat_folder <- "Organised RNA-seq count files"
dat_subfolders <- list.dirs(dat_folder)
dat_subfolders <- dat_subfolders[c(-1, -2, -3, -13, -14)]

# folders containing
dat_subfolders

# read count files
count_files <- list.files(dat_subfolders, pattern = "*ReadCounts.tsv", full.names = TRUE)
count_files

# UMI count files
umi_files <- list.files(dat_subfolders, pattern = "*BarcodeCounts.tsv", full.names = TRUE)
umi_files

# load all the read count files
read_dat <- map(count_files, read.delim, row.names = 1)

# load all the UMI count files
umi_dat <- map(umi_files, read.delim, row.names = 1)

read_dat_named <- read_dat %>% 
  set_names(c("hour_0", "hour_10", "hour_12", "hour_14", "hour_16", "hour_18", "hour_20", "hour_6", "hour_8"))

umi_dat_named <- umi_dat %>% 
  set_names(c("hour_0", "hour_10", "hour_12", "hour_14", "hour_16", "hour_18", "hour_20", "hour_6", "hour_8"))
```

# Load read and UMI data

The tables contain all 96 barcodes, but only 6 columns should contain counts.
When the folder name does not suggest any special arrangement, the first three barcodes refer to WT rep1, WT rep2 and WT rep3. 

In addition, each data file contains different rows. 
This is caused by the pipeline in which a filtering step was invoked. 
Here, the strategy is to assemble all data files and as long as a gene was recorded in a data file, 
the final data file will contain that gene. 0 count will be given to the samples in which those genes were absent. 

```{r include=FALSE}
tidy_celseq_dat <- function(df, time_point) {
  
  colnames(df) <- paste(rep(c("wt", "lox"), each = 3), time_point, c("rep1","rep2","rep3"), sep = "_")
  
  df %>% 
    rownames_to_column("gene_sequence_name") %>% 
    as_tibble()
}

# The tables contain all 96 barcodes, but only 6 columns should contain counts.
retrieve_celseq_dat <- function(df) {
  total_counts <- colSums(df)
  threshold_n <- sort(total_counts, decreasing = TRUE)[6]
  
  col_to_keep <- total_counts >= threshold_n
  dat_wt_lox <- df[,col_to_keep]
  
  return(dat_wt_lox)
}
```

```{r echo=FALSE, message=FALSE}
## Hour 6
read_dat_h6 <- read_dat_named$hour_6[,19:24] %>% 
  dplyr::rename(wt_hour06_rep1 = X19, 
         wt_hour06_rep2 = X20, 
         lox_hour06_rep1 = X21, 
         lox_hour06_rep2 = X22, 
         lox_hour06_rep3 = X23, 
         lox_hour10_rep3 = X24) %>% 
  rownames_to_column("gene_sequence_name") %>% 
  as_tibble() 

umi_dat_h6 <- umi_dat_named$hour_6[,19:24] %>% 
  dplyr::rename(wt_hour06_rep1 = X19, 
         wt_hour06_rep2 = X20, 
         lox_hour06_rep1 = X21, 
         lox_hour06_rep2 = X22, 
         lox_hour06_rep3 = X23, 
         lox_hour10_rep3 = X24) %>% 
  rownames_to_column("gene_sequence_name") %>% 
  as_tibble() 

## Hour 8
read_dat_h8 <- read_dat_named$hour_8 %>% 
  retrieve_celseq_dat() %>% 
  tidy_celseq_dat(time_point = "hour08")

umi_dat_h8 <- umi_dat_named$hour_8 %>% 
  retrieve_celseq_dat() %>% 
  tidy_celseq_dat(time_point = "hour08")

## Hour 10
read_dat_h10 <- read_dat_named$hour_10[,25:29] %>% 
  dplyr::rename(wt_hour10_rep1 = X25, 
         wt_hour10_rep2 = X26, 
         wt_hour10_rep3 = X27, 
         lox_hour10_rep1 = X28, 
         lox_hour10_rep2 = X29) %>% 
  rownames_to_column("gene_sequence_name") %>% 
  as_tibble()

umi_dat_h10 <- umi_dat_named$hour_10[,25:29] %>% 
  dplyr::rename(wt_hour10_rep1 = X25, 
         wt_hour10_rep2 = X26, 
         wt_hour10_rep3 = X27, 
         lox_hour10_rep1 = X28, 
         lox_hour10_rep2 = X29) %>% 
  rownames_to_column("gene_sequence_name") %>% 
  as_tibble()

# hour 12
read_dat_h12 <- read_dat_named$hour_12 %>% 
  retrieve_celseq_dat() %>% 
  tidy_celseq_dat(time_point = "hour12")

umi_dat_h12 <- umi_dat_named$hour_12 %>% 
  retrieve_celseq_dat() %>% 
  tidy_celseq_dat(time_point = "hour12")

# hour 14
read_dat_h14 <- read_dat_named$hour_14 %>% 
  retrieve_celseq_dat() %>% 
  tidy_celseq_dat(time_point = "hour14")

umi_dat_h14 <- umi_dat_named$hour_14 %>% 
  retrieve_celseq_dat() %>% 
  tidy_celseq_dat(time_point = "hour14")

# hour 16
read_dat_h16 <- read_dat_named$hour_16 %>% 
  retrieve_celseq_dat() %>% 
  tidy_celseq_dat(time_point = "hour16")

umi_dat_h16 <- umi_dat_named$hour_16 %>% 
  retrieve_celseq_dat() %>% 
  tidy_celseq_dat(time_point = "hour16")

# hour 18
read_dat_h18 <- read_dat_named$hour_18 %>% 
  retrieve_celseq_dat() %>% 
  tidy_celseq_dat(time_point = "hour18")

umi_dat_h18 <- umi_dat_named$hour_18 %>% 
  retrieve_celseq_dat() %>% 
  tidy_celseq_dat(time_point = "hour18")

# hour 20
read_dat_h20 <- read_dat_named$hour_20 %>% 
  retrieve_celseq_dat() %>% 
  tidy_celseq_dat(time_point = "hour20")

umi_dat_h20 <- umi_dat_named$hour_20 %>% 
  retrieve_celseq_dat() %>% 
  tidy_celseq_dat(time_point = "hour20")

# hour 0 will not be included
# because there is no lox for hour 0
read_dat_all <- read_dat_h6 %>% 
  full_join(read_dat_h8) %>% 
  full_join(read_dat_h10) %>% 
  full_join(read_dat_h12) %>% 
  full_join(read_dat_h14) %>% 
  full_join(read_dat_h16) %>% 
  full_join(read_dat_h18) %>% 
  full_join(read_dat_h20)

umi_dat_all <- umi_dat_h6 %>% 
  full_join(umi_dat_h8) %>% 
  full_join(umi_dat_h10) %>% 
  full_join(umi_dat_h12) %>% 
  full_join(umi_dat_h14) %>% 
  full_join(umi_dat_h16) %>% 
  full_join(umi_dat_h18) %>% 
  full_join(umi_dat_h20)
```

# Quality control

## Does swsn-1 "KO" work as expected?

My intuitive expectation is that I won't see swsn-1 mRNAs in all the "KO" samples (or very low level) and those mRNAs will be detected in wild type samples.

```{r echo=FALSE, message=FALSE, fig.width=8, fig.height=8}
# convert gene sequence name to gene name based on Wormbase
annotation.df <- read.csv("gene_annotation_wormbase.csv")

read_dat_all %>% 
  pivot_longer(-gene_sequence_name, names_to = "library_id", values_to = "read_count") %>% 
  left_join(annotation.df, by = c("gene_sequence_name" = "wormbase_gseq")) %>% 
  dplyr::filter(external_gene_id == "swsn-1") %>% 
  separate(library_id, into = c("genotype", "time_point", "sample_id"), remove = FALSE) %>% 
  mutate(genotype = factor(genotype, levels = c("wt", "lox"))) %>% 
  ggplot(aes(genotype, read_count)) + 
  geom_point(aes(color = time_point), position = position_jitter(width = 0.2), size = 3, alpha = 0.6) + 
  scale_color_brewer("Genotype", palette = "Dark2") + 
  labs(x = NULL, y = "Unnormalized read count") + 
  theme_bw() + 
  theme(axis.text.x = element_text(size = 12), 
        legend.position = c(0.1,0.8), 
        legend.background = element_rect(fill = "transparent"))
```

WOW! I observed swsn-1 mRNAs in "KO" group as well as wild type group. Why?

## Sequencing depth

```{r echo=FALSE, message=FALSE, fig.width=12, fig.height=8}
read_dat_long <- read_dat_all %>% 
  pivot_longer(-gene_sequence_name, names_to = 'library_id', values_to = 'read_count') %>% 
  mutate(read_count = ifelse(is.na(read_count), 0L, read_count)) %>% 
  separate(library_id, into = c("genotype", "time_point", "sample_id"), remove = FALSE)

seq_depth.df <- read_dat_long %>% 
  group_by(library_id) %>% 
  summarize(tot_read_count = sum(read_count))

ggplot(seq_depth.df, aes(library_id, tot_read_count)) + 
  geom_col() + 
  labs(x = NULL, y = "Total Read Counts") + 
  theme_bw() + 
  theme(axis.text.x = element_text(angle = 90))
```

Obviously, "wt_hour16_rep2", "wt_hour18_rep3" and "wt_hour20_rep3", as well as "lox_hour06_rep3" had unexpectedly low sequencing depth.

## Percentage of spike-in reads. 

If spike-ins account for too much sequencing depth, then much fewer reads will be available for endogenous genes.

```{r echo=FALSE, message=FALSE, fig.width=12, fig.height=8}
spike_read_dat <- read_dat_long %>% 
  dplyr::filter(!library_id %in% c("wt_hour16_rep2", "wt_hour18_rep3", "wt_hour20_rep3", "lox_hour06_rep3"), 
         str_detect(gene_sequence_name, pattern = "ERCC")) %>% 
  group_by(library_id, genotype) %>% 
  summarize(tot_spike_read_counts = sum(read_count)) %>% 
  left_join(seq_depth.df, by = "library_id") %>% 
  mutate(perc_ercc = tot_spike_read_counts / tot_read_count * 100)

ggplot(spike_read_dat, aes(tot_read_count, perc_ercc)) + 
  geom_point(aes(color = genotype), size = 3) + 
  ggrepel::geom_text_repel(data = dplyr::filter(spike_read_dat, perc_ercc > 4), aes(label = library_id)) + 
  scale_color_brewer("", palette = "Set2") + 
  labs(x = "Total read counts", y = "Spike-in reads (%)") + 
  theme_bw() + 
  theme(legend.position = "bottom")
```

Two samples have relatively higher percentage (~6%) of spike-in reads. 
According to CEL-seq protocol [@Hashimshony2012] The spike-in concentration should be chosen such that spike-in RNA contributes 1%–5% of the number of mRNA molecules. 
Here, I decided to keep these two samples for the downstream analysis. 

## UMIs in this project are not sufficient to uniquely tag the mRNAs to be sequenced

UMIs will reflect molecule counts only if the number of distinct labels is substantially larger than the typical number of identical molecules.

In Molly data set, UMIs are stretches of four random nucleotides integrated into a sequencing primer and serve as a random barcode for each mRNA molecule. 
Since $4^4 = 256$, this four-nucleotide UMI capable of distinguishing up to 256 molecules. 

```{r echo=FALSE, message=FALSE, fig.width=8, fig.height=8}
# remove the samples with low sequencing depth
read_dat_filtered <- read_dat_all[,!colnames(read_dat_all) %in% c("wt_hour16_rep2", "wt_hour18_rep3", "wt_hour20_rep3", "lox_hour06_rep3")]

umi_dat_filtered <- umi_dat_all[,!colnames(read_dat_all) %in% c("wt_hour16_rep2", "wt_hour18_rep3", "wt_hour20_rep3", "lox_hour06_rep3")]

read_dat_filtered_long <- read_dat_filtered %>% 
  pivot_longer(-gene_sequence_name, names_to = 'library_id', values_to = 'read_count') %>% 
  mutate(read_count = ifelse(is.na(read_count), 0L, read_count)) %>% 
  separate(library_id, into = c("genotype", "time_point", "sample_id"), remove = FALSE)

umi_dat_filtered_long <- umi_dat_filtered %>% 
  pivot_longer(-gene_sequence_name, names_to = 'library_id', values_to = 'umi_count') %>% 
  mutate(umi_count = ifelse(is.na(umi_count), 0L, umi_count)) %>% 
  separate(library_id, into = c("genotype", "time_point", "sample_id"), remove = FALSE)

read_umi_filtered_all <- read_dat_filtered_long %>% 
  left_join(umi_dat_filtered_long)

read_umi_filtered_all %>% 
  dplyr::filter(read_count != 0, library_id == "wt_hour08_rep3") %>% 
  ggplot(aes(log10(read_count), umi_count)) + 
  geom_point(shape =1 , color = "steelblue") + 
  geom_hline(yintercept = 256, color = "red", linetype = "dashed") + 
  labs(x = "log10(Read counts)", 
       y = "UMI counts", 
       title = "wt_hour08_rep3") + 
  #facet_wrap(~library_id, ncol = 4) + 
  scale_y_continuous(breaks = seq(from = 0, to = 256, length.out = 5)) + 
  theme_bw()
```

I showed a typical example in which genes with large read counts tended to have large UMI counts. 
When read counts become larger and larger, UMI counts are approaching 256. 
However, this doesn't mean that there are indeed 256 transcripts for all these genes. 
Likely, it is because UMIs are not sufficient to label all mRNAs. 
In fact, when UMI = 256, the data are right censored, because all we know is that the transcripts are at least 256 but can be more than that. 
Moreover, not only the genes with UMI = 256 are censored. 
The closer to 256 UMI count, the more likely that genes have the same issue. 
Nevertheless, UMIs will reflect molecule counts only if the number of distinct labels is **substantially larger** than the typical number of identical molecules.
As a result, these UMIs are not reliable because they can underestimate the gene expression. 
The consequence is that I cannot use this data set to estimate relative abundance (or any other relative abundance) for each gene. 
Read counts cannot help either, because they contain duplicated reads (PCR artifacts). 

## Batch effect

The $log2\frac{\text{read count}}{\text{UMI count}}$ indicated how many times an UMI was sequenced (or the number of reads per UMI), and was used to suggest PCR amplification [@Islam2014]. 

```{r echo=FALSE, fig.width=12, fig.height=8}
batch.df <- read_umi_filtered_all %>% 
  dplyr::select(library_id, time_point) %>% 
  distinct()

time_points <- unique(batch.df$time_point)
batch_numbers <- seq(from = 1, to = length(time_points), by = 1)
batch_ids <- str_c("batch", batch_numbers)

planed_batches <- data.frame(
  time_point = time_points, 
  batch_id = batch_ids
)

# However sample lox_hour10_rep3 was processed together with the hour06 samples
batch_final.df <- batch.df %>% 
  left_join(planed_batches, by = "time_point") %>% 
  mutate(batch_id = ifelse(library_id == "lox_hour10_rep3", "batch1", batch_id)) %>% 
  dplyr::select(-time_point)

pcr_amplif_df <- read_umi_filtered_all %>% 
  left_join(batch_final.df, by = "library_id") %>% 
  mutate(pcr_amp = log2(read_count / umi_count)) %>% 
  arrange(batch_id) 

genes_undefined_pcr_amp <- pcr_amplif_df %>% 
  dplyr::filter(is.na(pcr_amp)) %>% 
  dplyr::select(gene_sequence_name) %>% 
  distinct() %>% 
  pull()

pcr_amplif_df %>% 
  dplyr::filter(!gene_sequence_name %in% genes_undefined_pcr_amp) %>% 
  ggplot(aes(fct_inorder(library_id), pcr_amp, fill = time_point)) + 
  geom_boxplot() + 
  scale_fill_brewer("", palette = "Dark2") + 
  labs(x = NULL , y = "log2(read count / UMI count)") + 
  theme_bw() + 
  theme(axis.text.x = element_text(angle = 90), 
        legend.position = c(0.6,0.9), 
        legend.direction = "horizontal")
```

Here, we clearly see that this ratio varies from batch to batch. 
An important observation is that "lox_hour10_rep3" had very different $log2\frac{\text{read count}}{\text{UMI count}}$ compared to other "hour 10" samples. 
It seems that RNA libraries were constructed in batches and each batch contains wild type and lox samples from the same time point. 
Unfortunately, this is not good for investigating how gene expression changes over time even if UMI strategy were working properly. 
Why?
When we observe the expression level of a gene changes from hour 6 to hour 8, we do not know if that change is due to biology or is caused by different batch. 
What should have been done is randomizing the RNA library construction. 
What do I mean by that?
Yes, RNA libraries can still be prepared in batches, and yes every batch should contain both wild type and lox samples. 
However, each batch should also contain different time point samples, **NOT** the same time point samples. 

Since in this project we cannot work with the de-duplicated counts (UMIs are insufficient), we have to work with read counts (despite duplicate reads). 
Here I learned that within each batch (time point), the wild type and swsn-1 KO group would have similar duplication. 
When we perform differential expression analysis within each time point, the duplication effect will be canceled out. 
So, we can still learn which genes responded to swsn-1 KO at different time point. 
Unfortunately, we have to remove the sample "lox_hour10_rep3" from the downstream analysis. 

## Unnormalized read count data

After excluding the RNA samples mentioned above. 
I also filter out the genes that had zero read count in all remaining samples. 

```{r include=FALSE}
read_count_data_filtered <- read_umi_filtered_all %>% 
  dplyr::filter(library_id != "lox_hour10_rep3")

# if a gene has 0 count in all samples, that gene has to be removed
genes_zero_count_in_all_samples <- read_count_data_filtered %>% 
  group_by(gene_sequence_name) %>% 
  summarize(number_of_zero_count = mean(read_count == 0)) %>% 
  dplyr::filter(number_of_zero_count == 1) %>% 
  dplyr::pull(gene_sequence_name)

read_count_data_final <- read_count_data_filtered %>% 
  dplyr::filter(!gene_sequence_name %in% genes_zero_count_in_all_samples) %>% 
  dplyr::select(-umi_count) %>% 
  distinct()

#readr::write_csv(read_count_data_final, "Molly_unnormalized_after_qc_read_count_data.csv")

read_count_mat <- read_count_data_final %>% 
  dplyr::select(gene_sequence_name, library_id, read_count) %>% 
  spread(library_id, read_count) %>% 
  column_to_rownames(var = "gene_sequence_name") %>% 
  as.matrix()

# information on time point, genotype etc
meta_dat <- read_count_data_final %>% 
  dplyr::select(library_id, genotype, time_point) %>% 
  distinct() %>% 
  mutate(condition = str_c(genotype, time_point, sep = ".")) %>% 
  arrange(library_id)
```

The read count data we are going to use for differential expression analysis contain `r nrow(read_count_mat)` genes and `r ncol(read_count_mat)` samples. 
I saved the unnormalized read count data as a CSV file. 

# Normalization

## Before normalization

### Sequencing depth normalization is needed for this project

A large number of genes are unique to, or highly expressed in, one experimental conditions, the sequencing 'real estate' available for the remaining genes in that sample is decreased. If not adjusted for, this sampling artifact can force the differential expression analysis to be skewed towards one experimental condition. 

### What normalization do I **NOT** need for this project?

Since CEL-seq protocol currently sequences only a fragment of each molecule (15 bases from 5ʹ covering UMI and barcode, and 36 bases from the 3ʹ end of the transcript), correcting for transcript length during normalization is unnecessary.

### MD (mean-difference) plot of unnormalized counts

To visualize the need for normalization, I used the MD (mean-difference) plot of unnormalized counts. 
The x axis of MD plot stands for average log2-count
$$x = \frac{log2(\text{read count of sample A}) + log2(\text{read count sample B})}{2}$$. 
The y axis, log2-fold-change is defined as 
$$y = log2(\text{read count of sample A}) - log2(\text{read count sample B})$$.

```{r echo=FALSE, fig.width=8, fig.height=8}
ercc_count_data <- read_count_data_final %>% 
  dplyr::filter(str_detect(gene_sequence_name, "ERCC")) %>% 
  mutate(what_rna = "Spike-in")

endogenous_count_data <- read_count_data_final %>% 
  anti_join(ercc_count_data, by = "gene_sequence_name") %>% 
  mutate(what_rna = "Endogenous")

ercc_endogenous <- ercc_count_data %>% 
  bind_rows(endogenous_count_data) %>% 
  dplyr::filter(time_point == "hour14", genotype == "wt") %>% 
  dplyr::select(gene_sequence_name, library_id, read_count, what_rna) %>% 
  spread(library_id, read_count) %>% 
  dplyr::filter(wt_hour14_rep1 != 0, wt_hour14_rep3 != 0) %>% 
  mutate(M = (log2(wt_hour14_rep1) + log2(wt_hour14_rep3))/2, 
         D = log2(wt_hour14_rep1) - log2(wt_hour14_rep3)) 

plot_MD(ercc_endogenous)
```

Since I am comparing two replicates from a specific time point and treatment group, log2-fold-changes of most endogenous genes should be scattered around the horizontal zero line. 
Moreover, spike-ins are expected to have log2-fold-changes of zero. 
Apparently, rep1 had smaller count compared to rep3, indicating need for normalization. 

### Principal Component Analysis for unnormalized counts

```{r echo=FALSE, fig.width=12, fig.height=12}
sketch_PCA(read_count_mat)
```

In the next step, I performed principal component analysis (PCA) on unnormalized counts (log scale, centered). 
Each point corresponds to one sample. 
We can see that replicates with the same condition (time point and genotype) showed variation along the first principal component. 
This can be due to sequencing depth. 
Interestingly, the second principal component seems to separate samples before hour 12 and samples after hour 12.
The third principal component suggests that samples derived from hour 14 and 16 somehow are different from the rest. 

Many normalization methods assume that the absolute amount of total mRNA in each cell is similar across different cell types or experimental perturbations. 
Based on this assumption, normalized signals for different samples from different experiments should be scaled to have the same median or average value or that the distributions of signal intensities for each experiment within a set should all be the same. 
However, here swsn-1, a chromatin remodeller, was knocked out. 
This perturbation could lead to the two cells express a similar set of genes, but one cell produces and accumulates two to three times more RNA per gene for many of the same genes expressed in the other cell. 

## Using RUVr (Remove Unwanted Variation with residuals) [@Risso2014] for normalization 

There are some features in this experiment. 

1. Every RNA sample is derived from 2,000 M lineage cells. 
2. within each time point, we have a classical differential setting (swsn-1 "KO" vs. wild-type). 

In other words, this experiment only cares about gene expression changes caused by different time points and genotypes. 
The rest variations in gene expression are unrelated or unwanted. 
RUVr first ran negative binomial regression with the known factors (time point and genotype) and calculated the residuals for each gene in each sample. 
Here, residuals mean that the part that the gene expression values cannot be explained by time point or genotype, and are assumed to be caused by other unobserved (also unwanted) factors. 
To estimate these unwanted factors, RUVr performs the singular value decomposition (SVD) of the residual matrix.
These unwanted factors will be used for differential expression analysis later. 
The normalized read counts are actually the raw read counts subtracting the residuals. 
This approach was implemented in RUVr function in RUVseq package. 

**IMPORTANT** even though we can get normalized read counts here, these normalized read counts still suffer from duplicate reads. 
Therefore, these normalized counts cannot be used blindly to represent (relative) abundances of genes at different time points.
In short we should not use these normalized counts for developing the ODE model. 

```{r include=FALSE}
# filter out RIT and ERCC genes
# RIT no gene annotation
# ERCC gene will be different between time points (PCR amplifcation) but should not be different within each time point (same batch)
# this is different from the endogenous genes (design matrix will not be the same)
read_count_mat_filtered <- read_count_mat[!str_detect(row.names(read_count_mat), "RIT|ERCC"),]
```

```{r include=FALSE}
# make sure that the colnames of count matrix is the same as the meta data
identical(colnames(read_count_mat_filtered), meta_dat$library_id)

my_design0 <- model.matrix(~0 + condition, data = meta_dat)

colnames(my_design0) <- str_replace(colnames(my_design0), "condition", "")

# I set offsets to be 0 because global scaling normalization may be inappropriate for this experiment
# in this way the first unwanted factor must pick up the library size difference
my_offsets <- matrix(0L, nrow = nrow(read_count_mat_filtered), ncol = ncol(read_count_mat_filtered))

#my_dispersions0 <- estimateDisp(read_count_mat_filtered, design = my_design0, offset = my_offsets)
#my_fit0 <- glmFit(read_count_mat_filtered, design = my_design0, dispersion = my_dispersions0$tagwise.dispersion, offset = my_offsets)
#my_res0 <- residuals(my_fit0, type = "deviance")
#readr::write_rds(my_res0, "molly_residual_matrix.rds")
```

```{r echo=FALSE, fig.width=12, fig.height=6}
my_res0 <- readr::read_rds("molly_residual_matrix.rds")

# PCA of residual matrix
s <- svd(my_res0)
d0 <- s$d
data.frame(PC = seq(1, length(d0)), var_exp = d0^2/sum(d0^2)) %>% 
  ggplot(aes(PC, var_exp)) + 
  geom_point(size = 3) + 
  theme_bw() + 
  labs(x = "Unwanted factor", 
       y = "Variance explained") + 
  theme(axis.title = element_text(size = 14), 
        axis.text = element_text(size = 12))
```

```{r include=FALSE}
#ruv_out <- RUVSeq::RUVr(read_count_mat_filtered, cIdx = row.names(read_count_mat_filtered), k = 2, residuals = my_res0)

#W_hat.df <- ruv_out$W %>% 
#  as.data.frame()

#row.names(W_hat.df) <- colnames(read_count_mat_filtered)

#W_hat.df <- W_hat.df %>% 
#  rownames_to_column("library_id") %>% 
#  as_tibble()

#readr::write_csv(W_hat.df, "Molly_unwanted_factors.csv")
W_hat.df <- readr::read_csv("Molly_unwanted_factors.csv")

# Normalized read count 
#normalized_read_count_mat <- ruv_out$normalizedCounts

#normalized_read_count_df <- normalized_read_count_mat %>% 
#  as.data.frame() %>% 
#  rownames_to_column("gene_sequence_name") %>% 
#  as_tibble() %>% 
#  pivot_longer(-gene_sequence_name, names_to = "library_id", values_to = "read_count") %>% 
#  separate(library_id, into = c("genotype", "time_point", "sample_id"), remove = FALSE)

#readr::write_csv(normalized_read_count_df, "Molly_normalized_after_qc_read_count_data.csv")
```

```{r echo=FALSE, fig.width=8, fig.height=8}
W_hat.df %>% 
  left_join(seq_depth.df, by = "library_id") %>% 
  ggplot(aes(W_1, log10(tot_read_count))) + 
  geom_smooth(method = "lm", se = FALSE) + 
  geom_point(size = 3) + 
  labs(x = "log10(sequencing depth)", y = "Unwanted factor 1") + 
  theme_bw()
```

As expected, we can clearly see that the first unwanted factor (W_1) picks up the sequencing depth difference. 
I could not find that the second unwanted factor (W_2) was correlated with either PCR amplification ratio nor percentage of zero count. 

## After normalization

### MD plot showed that normalization worked

```{r echo=FALSE, message=FALSE, fig.width=8, fig.height=8}
normalized_read_count_df <- readr::read_csv("Molly_normalized_after_qc_read_count_data.csv")

normalized_read_count_df %>% 
  dplyr::filter(time_point == "hour14", genotype == "wt") %>% 
  dplyr::mutate(what_rna = "Endogenous") %>% 
  dplyr::select(gene_sequence_name, library_id, read_count, what_rna) %>% 
  spread(library_id, read_count) %>% 
  dplyr::filter(wt_hour14_rep1 != 0, wt_hour14_rep3 != 0) %>% 
  mutate(M = (log2(wt_hour14_rep1) + log2(wt_hour14_rep3))/2, 
         D = log2(wt_hour14_rep1) - log2(wt_hour14_rep3)) %>% 
  plot_MD()
```

In the MD-plot of RUVr-normalized read count for the sample wild type samples in the previous, we clearly see that log2-fold-changes are now scattered around the zero line. 
Since I removed the spike-in and RIT genes at beginning, here the plot does not show spike ins.

### The scatterplot matrix of first three principal components after RUVr normalization (log scale, centered)

```{r echo=FALSE, fig.width=12, fig.height=12}
normalized_read_count_mat <- normalized_read_count_df %>% 
  dplyr::select(gene_sequence_name, library_id, read_count) %>% 
  spread(library_id, read_count) %>% 
  column_to_rownames("gene_sequence_name") %>% 
  as.matrix()
sketch_PCA(normalized_read_count_mat[rowSums(normalized_read_count_mat)>0,])
```

Now, when we investigate the PCA of normalized read counts (log scale, centered), we can clearly see that replicate libraries derived from the same condition cluster together. 

### Sample-to-sample distance

```{r echo=FALSE, fig.width=12, fig.height=12}
library(RColorBrewer)
library(pheatmap)

sample_dists <- dist(t(log(normalized_read_count_mat + 1)))

plot(hclust(sample_dists, method = "complete"))

sample_dist_mat <- as.matrix(sample_dists)
colnames(sample_dist_mat) <- NULL
my_colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(sample_dist_mat,
         clustering_distance_rows=sample_dists,
         clustering_distance_cols=sample_dists,
         col=my_colors)
```

## Differential expression analysis

As I stated previously, due to lack of randomization during library construction, we cannot study gene expression changes over time, because the batch is confounding with the time point. 
However, this data set still allows us to answer "which genes respond to swsn-1 "KO" at each time point?". 
For differential expression analysis, I used the edgeR R package [@Robinson2010b], in which negative binomial regression model and gene-specific dispersion were used. 
The unwanted factors that were estimated in the previous step were incorporated into the design matrix. 
In principle, DESeq2 will give similar results since it also uses negative binomial regression model.
I chose edgeR because I am familiar with its functions and I can precisely control what the regression should do (default settings are not suitable for this project). 

```{r}
# unwanted factors estimated from RUVr
W_1 <- W_hat.df$W_1
W_2 <- W_hat.df$W_2

# design matrix
my_design <- model.matrix(~0 + condition + W_1 + W_2, data = meta_dat)

colnames(my_design) <- str_replace(colnames(my_design), "condition", "")

# gene-specific dispersion
#my_dispersions <- estimateDisp(read_count_mat_filtered, design = my_design, offset = my_offsets)

# negative binomial regression
#my_fit <- glmFit(read_count_mat_filtered, design = my_design, dispersion = my_dispersions$tagwise.dispersion, offset = my_offsets)

my_contrasts <- makeContrasts(
  h6.loxVSwt = lox.hour06 - wt.hour06, 
  h8.loxVSwt = lox.hour08 - wt.hour08, 
  h10.loxVSwt = lox.hour10 - wt.hour10, 
  h12.loxVSwt = lox.hour12 - wt.hour12, 
  h14.loxVSwt = lox.hour14 - wt.hour14, 
  h16.loxVSwt = lox.hour16 - wt.hour16, 
  h18.loxVSwt = lox.hour18 - wt.hour18, 
  h20.loxVSwt = lox.hour20 - wt.hour20, 
  h12vsh14 = (lox.hour14 - wt.hour14) - (lox.hour12 - wt.hour12),
  levels = my_design
)

#readr::write_rds(my_fit, "Molly_NB_fit.rds")
#my_fit <- readr::read_rds("Molly_NB_fit.rds")
```

# Results

## Differential expression at each time point

I used volcano plots to display gene expression changes responding to swsn-1 "KO" at each time point (swsn-1 "KO" was compared with wild type at each time point). 
Every dot represents a gene and the red ones are the ones with FDR (false discovery rate) below 0.01. 
The top 10 genes in each time point were highlighted. 
I observed massive gene expression changes due to swsn-1 "KO", especially in the late stage. 

```{r include=FALSE}
#gene_stats_h6_lox_vs_wt <- glmLRT(my_fit, contrast = my_contrasts[,"h6.loxVSwt"]) %>% 
#  tidy_togTags(annotation.df) %>% 
#  mutate(time_point = "Hour06")

#gene_stats_h8_lox_vs_wt <- glmLRT(my_fit, contrast = my_contrasts[,"h8.loxVSwt"]) %>% 
#  tidy_togTags(annotation.df) %>% 
#  mutate(time_point = "Hour08")

#gene_stats_h10_lox_vs_wt <- glmLRT(my_fit, contrast = my_contrasts[,"h10.loxVSwt"]) %>% 
#  tidy_togTags(annotation.df) %>% 
#  mutate(time_point = "Hour10")

#gene_stats_h12_lox_vs_wt <- glmLRT(my_fit, contrast = my_contrasts[,"h12.loxVSwt"]) %>% 
#  tidy_togTags(annotation.df) %>% 
#  mutate(time_point = "Hour12")

#gene_stats_h14_lox_vs_wt <- glmLRT(my_fit, contrast = my_contrasts[,"h14.loxVSwt"]) %>% 
#  tidy_togTags(annotation.df) %>% 
#  mutate(time_point = "Hour14")

#gene_stats_h16_lox_vs_wt <- glmLRT(my_fit, contrast = my_contrasts[,"h16.loxVSwt"]) %>% 
#  tidy_togTags(annotation.df) %>% 
#  mutate(time_point = "Hour16")

#gene_stats_h18_lox_vs_wt <- glmLRT(my_fit, contrast = my_contrasts[,"h18.loxVSwt"]) %>% 
#  tidy_togTags(annotation.df) %>% 
#  mutate(time_point = "Hour18")

#gene_stats_h20_lox_vs_wt <- glmLRT(my_fit, contrast = my_contrasts[,"h20.loxVSwt"]) %>% 
#  tidy_togTags(annotation.df) %>% 
#  mutate(time_point = "Hour20")

#gene_stats_lox_vs_wt <- gene_stats_h6_lox_vs_wt %>% 
#  bind_rows(gene_stats_h8_lox_vs_wt) %>% 
#  bind_rows(gene_stats_h10_lox_vs_wt) %>% 
#  bind_rows(gene_stats_h12_lox_vs_wt) %>% 
#  bind_rows(gene_stats_h14_lox_vs_wt) %>% 
#  bind_rows(gene_stats_h16_lox_vs_wt) %>% 
#  bind_rows(gene_stats_h18_lox_vs_wt) %>% 
#  bind_rows(gene_stats_h20_lox_vs_wt)

#readr::write_csv(gene_stats_lox_vs_wt, "Molly_gene_stats_lox_vs_wt.csv")
```

```{r echo=FALSE, fig.width=12, fig.height=24, message=FALSE}
gene_stats_lox_vs_wt <- readr::read_csv("results/Molly_gene_stats_lox_vs_wt.csv")

sig_genes <- gene_stats_lox_vs_wt %>% 
  dplyr::filter(FDR < 0.01)

sig_genes_to_be_annotated <- sig_genes %>% 
  group_by(time_point) %>% 
  top_n(-FDR, n = 10)

ggplot(gene_stats_lox_vs_wt, aes(logFC, -log10(PValue))) + 
  geom_point(alpha = 0.1) + 
  geom_point(data = sig_genes, color = "red", alpha = 0.2) + 
  ggrepel::geom_text_repel(data = sig_genes_to_be_annotated, aes(label = external_gene_id)) + 
  theme_bw() + 
  facet_wrap(~time_point, ncol = 4, scale = "free")
```

## Genes of interest for ODE model development

For the purpose of building ODE models, I am particularly interested in genes such as mls-2, hlh-1 and cdk-4 etc. 
Here I showed how swsn-1 "KO" will affect these genes at different time point. 
**WARNING** I would be very cautious about the time course of these genes because of the batch effect. 
We do not know whether the gene expression changes from one time point to another is due to biology or due to different batches (for example PCR amplification). 

```{r echo=FALSE, fig.width=12, fig.height=12}
target_genes <- annotation.df %>% 
  dplyr::filter(external_gene_id %in% c("mls-2", "hlh-1", "cdk-4", "cyd-1", "cki-1", "unc-15", "fos-1", "jun-1"))

normalized_read_count_df %>% 
  inner_join(target_genes, by = c("gene_sequence_name" = "wormbase_gseq")) %>% 
  mutate(external_gene_id = factor(external_gene_id, levels = c("mls-2", "hlh-1", "cdk-4", "cyd-1", "cki-1", "unc-15", "fos-1", "jun-1")), 
         genotype = factor(genotype, levels = c("wt", "lox"))) %>% 
  ggplot(aes(genotype, log(read_count + 1))) + 
  geom_point(aes(color = genotype), size = 2, position = position_jitter(width = 0.2)) + 
  scale_color_brewer("", palette = "Set2") + 
  facet_grid(external_gene_id~time_point, scales = "free") + 
  labs(x = NULL, y = "log(Normalized Read Counts + 1)") + 
  theme_bw() + 
  theme(legend.position = "none")
```

### mls-2

What I learned here is that mls-2 was down-regulated in swsn-1 "KO" group at hour 8. 
In contrast, mls-2 was up-regulated in swsn-1 "KO" group at hour 12 and 14. 
The detail gene-level statistics are given below. 

```{r echo=FALSE}
gene_stats_lox_vs_wt %>% 
  dplyr::filter(external_gene_id == "mls-2") %>% 
  knitr::kable()
```

### hlh-1

hlh-1 was up-regulated in swsn-1 "KO" group at hour 8, 18 and 20. 

```{r echo=FALSE}
gene_stats_lox_vs_wt %>% 
  dplyr::filter(external_gene_id == "hlh-1") %>% 
  knitr::kable()
```

### cdk-4

cdk-4 was up regulated in swsn-1 "KO" group at hour 14, 16, 18 and 20. 

```{r echo=FALSE}
gene_stats_lox_vs_wt %>% 
  dplyr::filter(external_gene_id == "cdk-4") %>% 
  knitr::kable()
```

### cyd-1

Meanwhile, cyd-1 was up regulated in swsn-1 "KO" group at hour 8, 12, 14, 18 and 20. 

```{r echo=FALSE}
gene_stats_lox_vs_wt %>% 
  dplyr::filter(external_gene_id == "cyd-1") %>% 
  knitr::kable()
```

### cki-1

cki-1 represents a negative cell cycle regulator.

cki-1 was down-regulated in swsn-1 "KO" group at hour 12, and then cki-1 was up-regulated in swsn-1 "KO" group at hour 14. 
cki-1 was up-regulated in swsn-1 "KO" group at hour 20. 

```{r echo=FALSE}
gene_stats_lox_vs_wt %>% 
  dplyr::filter(external_gene_id == "cki-1") %>% 
  knitr::kable()
```

### unc-15

unc-15 is used as a marker for differentiation. 
Here, unc-15 was down-regulated in swsn-1 "KO" group at hour 14, 16 and 18 compared to the wild type group. 

```{r echo=FALSE}
gene_stats_lox_vs_wt %>% 
  dplyr::filter(external_gene_id == "unc-15") %>% 
  knitr::kable()
```

### fos-1

```{r echo=FALSE}
gene_stats_lox_vs_wt %>% 
  dplyr::filter(external_gene_id == "fos-1") %>% 
  knitr::kable()
```

### jun-1

```{r echo=FALSE}
gene_stats_lox_vs_wt %>% 
  dplyr::filter(external_gene_id == "jun-1") %>% 
  knitr::kable()
```

## Use relative expression to track qualitative gene expression changes over time

In the "Batch effect" section, I used PCR amplification bias to indicate batch effects.
It is clear that on average the batch effect is strongest at hour 14, followed by hour 16.  

Regarding the model genes, we can clearly see that the model genes were also affected by batch effects. 
Except mls-2, all these genes showed strong PCR amplification bias at hour 14. 
This is consistent with the general PCR amplification bias observation mentioned above. 

Additionally, I also learned that different genes showed different patterns. 
I used the LOESS to show the trend. 

```{r echo=FALSE, message=FALSE, warning=FALSE, fig.width=9, fig.height=9}
pcr_amplif_df %>% 
  inner_join(target_genes, by = c("gene_sequence_name" = "wormbase_gseq")) %>% 
  dplyr::filter(!library_id %in% "lox_hour10_rep3") %>% 
  mutate(t_shifted = str_sub(time_point, 5, -1), 
         t_shifted = as.numeric(t_shifted), 
         t_shifted = t_shifted - 6) %>% 
  ggplot(aes(t_shifted, pcr_amp)) + 
  geom_point(size = 3, alpha = 0.5) + 
  geom_smooth(se = FALSE) + 
  scale_x_continuous(breaks = seq(0, 14, 2), labels = str_c("Hour", seq(6, 20, 2))) + 
  facet_wrap(~external_gene_id, scales = "free") + 
  labs(x = NULL , y = "log2(read count / UMI count)") + 
  theme_bw() + 
  theme(axis.text.x = element_text(angle = 90))
```

```{r include=FALSE, message=FALSE}
spikein_present_all_samples <- read_count_data_final %>% 
  dplyr::filter(str_detect(gene_sequence_name, 'ERCC')) %>% 
  group_by(gene_sequence_name) %>% 
  summarize(with_zero_read = sum(read_count == 0L)) %>% 
  dplyr::filter(with_zero_read == 0L) %>% 
  dplyr::pull(gene_sequence_name)
```

There are `r length(spikein_present_all_samples)` ERCC spike-ins present in all samples. 

```{r echo=FALSE, message=FALSE, fig.width=12, fig.height=12}
pcr_amplif_df %>% 
  dplyr::filter(gene_sequence_name %in% spikein_present_all_samples, 
                !library_id %in% "lox_hour10_rep3") %>% 
  mutate(t_shifted = str_sub(time_point, 5, -1), 
         t_shifted = as.numeric(t_shifted), 
         t_shifted = t_shifted - 6) %>% 
  ggplot(aes(t_shifted, pcr_amp)) + 
  geom_point(size = 2, alpha = 0.5) + 
  geom_smooth(se = FALSE) + 
  scale_x_continuous(breaks = seq(0, 14, 2), labels = str_c("Hour", seq(6, 20, 2))) + 
  facet_wrap(~gene_sequence_name, scales = "free") + 
  labs(x = NULL , y = "log2(read count / UMI count)") + 
  theme_bw() + 
  theme(axis.text.x = element_text(angle = 90))
```

Relatively spike-in "ERCC-00113" showed a similar pattern of batch effect as cdk-4, cki-1, cyd-1 and hlh-1. 
I also found that "ERCC-00095" approximated well the general batch effect. 

```{r echo=FALSE, warning=FALSE, message=FALSE, fig.width=8, fig.height=8}
pcr_amplif_df %>% 
  dplyr::filter(gene_sequence_name == "ERCC-00095", 
                !library_id %in% "lox_hour10_rep3") %>% 
  mutate(t_shifted = str_sub(time_point, 5, -1), 
         t_shifted = as.numeric(t_shifted), 
         t_shifted = t_shifted - 6) %>% 
  ggplot(aes(t_shifted, pcr_amp)) + 
  geom_point(size = 3, alpha = 0.5) + 
  geom_smooth(se = FALSE) + 
  scale_x_continuous(breaks = seq(0, 14, 2), labels = str_c("Hour", seq(6, 20, 2))) + 
  labs(x = NULL , y = "log2(read count / UMI count)") + 
  theme_bw() + 
  theme(axis.text.x = element_text(angle = 90))
```

"ERCC-00095" contains 0, which will lead to NA relative expression. 
However, these 0 read counts were in "lox" group, so relative expression will be okay for wild type.

```{r}
ercc95 <- read_count_data_final %>% 
  dplyr::filter(gene_sequence_name == "ERCC-00095") %>% 
  rename(ercc95_read_count = read_count) %>% 
  dplyr::select(-gene_sequence_name)

ercc95 %>% 
  dplyr::filter(ercc95_read_count == 0)
```

Anyway, I cannot find any other spiked-ins that showed similar pattern as fos-1, unc-15 as well as mls-2.

Since the amount of spiked-in material is assumed to be constant across samples, the read counts difference between time points is driven by factors such as sequencing depth and batch effect. 
When I use "ERCC-00095" this only works for cdk-4, cki-1, cyd-1 and hlh-1. 
The *BIG* assumption is that "ERCC-00095" affected by batch effect similar to those four genes. 
If I use this gene as reference ($S$), then I can track the relative gene expression changes over time. 

$$\text{Relative Expression of }X_{t} = log2(\frac{X_{t}}{S_{t}})$$
$$
\begin{align}
RE(X_{t1}) - RE(X_{t2}) &= log2(\frac{X_{t1}}{S_{t1}}) - log2(\frac{X_{t2}}{S_{t2}}) \\
                        &= log2(\frac{X_{t1}}{X_{t2}}) - log2(\frac{S_{t1}}{S_{t2}})
\end{align}
$$

Here, I assumed that $log2(\frac{S_{t1}}{S_{t2}})$ contains artificial time effects due to factors such as sequencing depth and batch effects. 

```{r echo=FALSE, message=FALSE, fig.width=10, fig.height=12}
model_genes_expression <- read_count_data_final %>% 
  inner_join(target_genes, by = c("gene_sequence_name" = "wormbase_gseq")) %>% 
  dplyr::filter(external_gene_id %in% c("hlh-1", "cyd-1", "cdk-4", "cki-1")) %>% 
  left_join(ercc95, by = c("library_id", "genotype", "time_point", "sample_id")) %>% 
  mutate(relative_expression = log2(read_count) - log2(ercc95_read_count)) %>% 
  mutate(external_gene_id = factor(external_gene_id, levels = c("hlh-1", "cyd-1", "cdk-4", "cki-1")), 
         t_shifted = str_sub(time_point, 5, -1), 
         t_shifted = as.numeric(t_shifted), 
         t_shifted = t_shifted - 6)

#readr::write_csv(model_genes_expression, "model_genes_relative_expression.csv")

ggplot(model_genes_expression, aes(t_shifted, relative_expression)) + 
  geom_point(size = 2) + 
  geom_smooth(se = FALSE) + 
  scale_x_continuous(breaks = seq(0, 14, 2), labels = str_c("Hour", seq(6, 20, 2))) + 
  scale_color_brewer(palette = "Set2") + 
  facet_grid(external_gene_id~genotype, scales = "free_y") + 
  labs(x = NULL, y = "Relative expression (log2 scale)") + 
  theme_bw() + 
  theme(legend.position = "bottom", 
        axis.text.x = element_text(angle = 90))
```

# Conclusion

This is a bulk RNAseq data produced by a scRNAseq protocol (CEL-seq). 
Some important things I learned here. 

1. UMIs with four random nucleotides are not sufficient to label all mRNAs, leading to over-deduplication and underestimation of gene expression. The most important thing is that UMI works only when UMIs substantially larger than the number of independent RNA molecules. 
2. Because UMIs do not work, we have to work with read counts (But read counts suffer from duplicated reads). 
3. Library construction can be done in batches, but within a batch different time point samples should be randomized. Otherwise, we have no chance to study gene expression changes over time. 
4. Perturbation of swsn-1 may cause global changes in gene expression. As mentioned previously [@Loven2012], Applying the normalization approaches that assume "most things remain the same, few things change" may lead to misinterpretation. 
5. Using relative expression levels may allow me to qualitatively track some gene expression changes over time. 

# Reference
